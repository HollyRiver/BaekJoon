## 정수 X에 사용할 수 있는 연산은 세가지임
## 1 : X가 3으로 나누어 떨어지면, 3으로 나눈다
## 2 : X가 2로 나누어 떨어지면, 2로 나눈다.
## 3 : 1을 뺀다.

## 정수 N이 주어졌을 때, 위 연산 세가지를 적절히 사용하여 1을 만들려고 함.
## 연산 횟수 최소값 출력

## 개귀찮네

## 어케함???

## 3과 2의 제곱수를 만들어놓고 그것을 만들도록 하는 게 중요할 것 같은데

## 1. 안나눠지면 무조건 1을 빼야 한다.
## 2. 1을 빼면 무조건 2로 나눠진다. 그런데 2로 나누는 것이 최선이 아닐 수 있다.
## 3. 3으로 나누는 게 가장 많이 줄어들지만, 이것이 최선이 아닐 수 있다.

# 1 -> 끝
# 2 -> 빼거나 나눔, 끝
# 3 -> 나눔, 끝
# 4 -> 나누고 나눔, 끝
# 5 -> 빼고 나누고 나눔, 끝
# 6 -> 나누고 나눔, 끝
# 7 -> 빼고 나누고 나눔, 끝
# 8 -> 나누고 나누고 나눔, 끝
# 9 -> 나누고 나눔, 끝
# 10 -> 2로 나눌 수 있음, 하지만 9에 가까우므로 1을 빼고 나누고 나눠서 끝
# 11 -> 빼고 10과 동일
# 12 -> 2와 3으로 나타낼 수 있음
# 13 -> 빼고 12와 동일
# 14 -> 나누고 빼고 나누고 나누고.
# 15 -> 어케함? 규칙이 있나?

[0, 1, 1, 2, 3, 2, 3, 3, 2, 3, 4, 3, 4, 4, ]

## 2와 3의 곱만으로 나타낼 수 있는 것은 그대로 나누는 게 가장 빠름
## 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 32, 36, ...
## 해당 값에 가깝게 만들수만 있다면... 횟수를 줄일 수 있음
## 존나 어렵다

## 초반 5개 항까지만 하드코딩으로 박아넣음
minimum_value = [0, 1, 1, 2, 3]
snd_method = 10**6
fst_method = 10**6

for i in range(6, 10**6+1) :
    if i%2 == 0 :
        snd_method = minimum_value[int(i/2) - 1] + 1
    
    if i%3 == 0 :
        fst_method = minimum_value[int(i/3) - 1] + 1
        
    trd_method = minimum_value[i-2] + 1
    
    minimum_value.append(min([snd_method, fst_method, trd_method]))
    
    snd_method = 10**6
    fst_method = 10**6
    
N = int(input())
print(minimum_value[N-1])